
#include "shared.h"

const char *foo() {
  return "example string";
}

const char *bar() {
  return "another example string";
}

/* PLT entries assume that %ebx is set up on entry on x86-32.  They
   therefore don't work as address-taken functions.  The address-taken
   version should be read from the GOT instead. */
extern void *pltgot_imports[];
asm(".pushsection \".text\",\"ax\",@progbits\n"
    "slowpath_common:\n"
    "push plt_handle@GOTOFF(%ebx)\n"
    "jmp *plt_trampoline@GOTOFF(%ebx)\n"
    ".popsection\n"
    /* Start of PLTGOT table. */
    ".pushsection \".my_pltgot\",\"aw\",@progbits\n"
    "pltgot_imports:\n"
    ".popsection\n"
    );

/* These PLT entries are more compact than those generated by binutils
   because they can use the short forms of the "jmp" and "push"
   instructions. */
#define PLT_ENTRY(number, name) \
  asm(".pushsection \".text\",\"ax\",@progbits\n" \
      #name ":\n" \
      "jmp *pltgot_imports + 4 * " #number "@GOTOFF(%ebx)\n" \
      "slowpath_" #name ":\n" \
      "push $" #number "\n" \
      "jmp slowpath_common\n" \
      ".popsection\n" \
      /* Entry in PLTGOT table */ \
      ".pushsection \".my_pltgot\",\"aw\",@progbits\n" \
      ".long slowpath_" #name "\n" \
      ".popsection\n");

const char *import_func0();
const char *import_func1();

PLT_ENTRY(0, import_func0)
PLT_ENTRY(1, import_func1)

const char *test_import0() {
  return import_func0();
}

const char *test_import1() {
  return import_func1();
}

void *function_table[] = {
  (void *) foo,
  (void *) bar,
  (void *) test_import0,
  (void *) test_import1,
};

void *plt_trampoline;

struct prog_header prog_header = {
  .plt_trampoline = &plt_trampoline,
  .pltgot = &pltgot_imports,
  .user_info = function_table,
};

struct prog_header *plt_handle = &prog_header;
